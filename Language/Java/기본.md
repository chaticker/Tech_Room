### 객체지향 프로그래밍(Object Oriented Programming)

  -프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고, 그 객체들간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 기법
  
  - 장점
    * 재사용성 향상
    * 유지보수 용이
    * 대형 프로젝트에 적합
    
  - 단점
    * 처리 속도가 상대적으로 느림
    * 객체가 많으면 용량이 커질 수 있음
    * 설계시 많은 노력과 시간 필요
    
### 객체지향 프로그래밍 특징
  - 추상화: 불필요한 정보는 숨기고, 필요한 정보만을 표현함으로써 공통의 속성이나 기능을 묶어 이름을 붙이는 것
  - 캡슐화: 관련된 기능(메소드)과 속성(변수)을 한 곳에 모으고 분류하여 외부로부터의 위험에 대비하고 재사용성을 높이는 것
  - 상속: 부모 클래스의 속성과 기능을 그대로 물려 받아 사용할 수 있는 것 -> 자식 클래스에서 기능을 변경할 수 있음(오버라이딩)
  - 다형성: 하나의 변수 및 함수명 등이 상황에 따라 다른 의미로 해석될 수 있는 것
  
### 오버라이딩 vs 오버로딩
  - 오버라이딩: 상위 클래스가 가지고 있는 메소드를 하위 클래스에서 재정의하여 사용하는 것
  - 오버로딩: 같은 이름의 메소드를 여러개 가지면서 매개변수의 타입이나 개수를 다르게 하여 정의하는 것
  
### 클래스 & 인스턴스
  - 클래스: 어떤 문제를 해결하기 위한 데이터를 만들기 위해 추상화를 거쳐 집단에 속하는 속성과 행위를 변수와 메소드로 정의한 것
  - 인스턴스: 클래스에서 정의한 것을 토대로 실제 메모리 상에 할당된 것. 실제 프로그램에서 사용되는 데이터를 말함
  
### integer vs int
  - integer: Wrapper 클래스(객체) / 산술 연산 불가능 / null값을 가질 수 있음
  - int: primitive 자료형 / 산술 연산 가능 / null값 가질 수 없음
  
### == vs equals()
  - ==: 비교를 위한 연산자 -> 대상의 주소값을 비교
  - equals(): 메소드이며, 객체끼리 내용 비교 가능 -> 대상의 내용 자체를 비교
  
### call by value vs call by reference (java는 call by value임)
  - call by value: 원시 자료형의 경우 해당 인자의 값을 변경하더라도 원본 값은 바뀌지 않음-> int, short, long, float, double, char, boolean
  - call by reference: 참조 타입의 경우 변수가 가지는 값이 주소 값이 되므로 해당 인자의 값을 변경하게 되면 원본 값도 바뀌게 됨 -> array, 참조 타입
  
### Garbage Collection
  - 객체가 만들어지면서 메모리의 한 부분을 점유하게 되고, 특정 메소드를 호출한 후 수행이 완료되어 더 이상 필요 없는 객체를 효과적으로 처리하는 것
  
### JVM(Java Virtual Machine)
  - 스택 기반의 가상 머신
  - java와 OS 사이에서 중개 역할 수행 -> java가 OS에 구애받지 않고 재사용이 가능하도록 함
  - 메모리 관리, 즉 Garbage Collection을 수행
  - 자바 바이트 코드를 실행할 수 있는 주체

