## 1. Virtual Memory 1

### Demand Paging
* 실제로 필요할 때 page를 메모리에 올리는 것

* 이점
  - I/0 양의 감소(필요한 것만 올리기 때문)
  - 메모리 사용량 감소
  - 빠른 응답 시간
  - 더 많은 사용자 수용
  
* Valid / Invalid bit의 사용
  - Invalid의 의미
    * 사용되지 않는 주소 영역인 경우
    * 페이지가 물리적 메모리에 없는 경우
  - 처음에는 모든 page entry가 invalid로 초기화
  - address translation 시에 invalid bit이 set되어 있으면 -> **page fault**

![KakaoTalk_20201210_225848099](https://user-images.githubusercontent.com/23302973/101781581-592a8480-3b3b-11eb-8fc7-5df283f78e04.jpg)

![asdf asdf asd f](https://user-images.githubusercontent.com/23302973/101781722-85de9c00-3b3b-11eb-80d2-0c33b4e2e6c3.PNG)

![KakaoTalk_20201210_230854267](https://user-images.githubusercontent.com/23302973/101782710-b3781500-3b3c-11eb-9a3b-8607d8e9efbd.jpg)

![KakaoTalk_20201210_231601642](https://user-images.githubusercontent.com/23302973/101783498-b32c4980-3b3d-11eb-96ed-0f1d6ddd0417.jpg)

* page replacement
  - 어떤 프레임을 빼앗아올지 결정해야 함
  - 곧바로 사용되지 않을 페이지를 쫓아내는 것이 좋음
  - 동일한 페이지가 여러 번 메모리에서 쫓겨났다가 다시 들어올 수 있음
  
* Replacement Algorithm
  - page-fault rate을 최소화 하는 것이 목표
  - 가능하면 page-fault가 나지 않고 메모리에서 직접 처리할 수 있게 해줌
  
  - 알고리즘의 평가
    * 주어진 page reference string에 대해 page fault를 얼마나 내는지 조사
  - reference string의 예
    - 시간 순서에 따라서 페이지들을 서로 다른 순서로 붙여놓고, 페이지들이 참조된 순서를 나열한것
    * 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5

![KakaoTalk_20201210_233715415](https://user-images.githubusercontent.com/23302973/101785935-af4df680-3b40-11eb-8b48-036febb5728a.jpg)

* 실제 시스템에서 사용 불가능한 알고리즘

![KakaoTalk_20201210_234906966](https://user-images.githubusercontent.com/23302973/101787335-52534000-3b42-11eb-8bc6-71280456ba1e.jpg)

* 실제 시스템에서 사용 가능한 알고리즘

![KakaoTalk_20201210_235444234](https://user-images.githubusercontent.com/23302973/101788111-1d93b880-3b43-11eb-86a4-3fe38a501396.jpg)

![KakaoTalk_20201211_000202896](https://user-images.githubusercontent.com/23302973/101789028-220ca100-3b44-11eb-9e1f-a691b2ea3405.jpg)

![KakaoTalk_20201211_004337835](https://user-images.githubusercontent.com/23302973/101794174-f2609780-3b49-11eb-9c04-5a52b339ae8a.jpg)

![KakaoTalk_20201211_005352600](https://user-images.githubusercontent.com/23302973/101795582-63547f00-3b4b-11eb-888f-31809d624160.jpg)

![KakaoTalk_20201211_010721698](https://user-images.githubusercontent.com/23302973/101797345-4456ec80-3b4d-11eb-8a35-cadd9dc7d342.jpg)
-> LFU에서는 루트에 있는 페이지를 쫓아내면 됨(가장 적은 페이지 참조 횟수를 가지고 있으니까)

## 2. Virtual Memory 2

![asdfasdfasdf](https://user-images.githubusercontent.com/23302973/101873923-38aa0b00-3bcb-11eb-8f1c-c40d5098cc94.PNG)
-> LRU, LFU를 사용할 수 없기 때문에 Clock Algorithm(NUR, NRU)을 사용

![KakaoTalk_20201211_163018245](https://user-images.githubusercontent.com/23302973/101875564-2ed5d700-3bce-11eb-943c-a81fd44f3bc4.jpg)

![KakaoTalk_20201211_163936537](https://user-images.githubusercontent.com/23302973/101876253-7c9f0f00-3bcf-11eb-8570-ceb11c228d71.jpg)



## 3. File Systems 1 

## 4. File System Implementations 1 
